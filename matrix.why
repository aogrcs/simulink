(* Created by Dejanira Araiza-Illan and Arthur Richards, UoB, 2014 *)

theory Matrix

  type matrix

  (* note size compatibility assumed throughout - must be checked numerically *)  

  (* start with basic ring axioms *)
  (* see https://en.wikipedia.org/wiki/Ring_(mathematics) *)
  (* properties defined as implications to avoid need for sizing *)

  (* matrix addition *)
  function mat_add matrix matrix : matrix
  (* add is commutative: if c = a+b then c = b+a *)
  axiom matadd1: forall a b c : matrix. (c = mat_add a b) -> (c = mat_add b a)
  (* add is associative iff d = a+(b+c) then d = (a+b)+c *)
  axiom matadd2: forall a b c d : matrix. (d = mat_add a (mat_add b c)) <-> (d = mat_add (mat_add a b) c)

  (* matrix subtraction *)
  function mat_subtract matrix matrix : matrix
  (* iff c=a+b then a=c-b *)
  axiom mat_subtract1: forall a b c : matrix. (c = mat_add a b) <-> (a = mat_subtract c b)
  
  (* and define the minus in terms of subtraction *)
  function mat_minus matrix : matrix
  (* define equivalence: iff c=a-b then c=a+(-b) *)
  axiom mat_minus_def: forall a b c : matrix. (c = mat_subtract a b) <-> (c = mat_add a (mat_minus b))
  (* try and give it a unique definition iff c = a+b then b = c+(-a) *)
  lemma mat_minus_add: forall a b c : matrix. (c = mat_add a b) <-> (b = mat_add c (mat_minus a))

  (* and in another form *)
  lemma mat_minus_rev: forall a b : matrix. (a = mat_minus b) <-> (b = mat_minus a)
  (* check that a+b+(-b) = a *)
  lemma mat_minus_chk: forall a b c : matrix. (c = mat_add a (mat_add b (mat_minus b))) -> (c=a)
  (* lemma of uniqueness of minus? *)
  lemma mat_minus_unq: forall a b : matrix. (a=b) <-> (mat_minus a = mat_minus b)
  (* lets see if it gets -(-a) = a *)
  lemma mat_minus_twice: forall a : matrix. mat_minus (mat_minus a) = a

  (* verify swapping terms in add *)
  lemma mat_sub_chk0: forall a b c : matrix. (c = mat_add b a) <-> (b = mat_subtract c a)
  (* and verify subtract works the other way round c=a+b then b=c-a *)
  lemma mat_sub_chk1: forall a b c : matrix. (c = mat_add a b) <-> (b = mat_subtract c a)
  (* verify subtraction undoes addition (a + b) - b = a *)
  lemma mat_sub_undo1: forall a b c : matrix. (c = mat_subtract (mat_add a b) b) -> (c=a)
  (* and also (a-b)+b = a *)
  lemma mat_sub_undo2: forall a b c : matrix. (c = mat_add (mat_subtract a b) b) -> (c=a)

  (* a+(b-c) = (a+b)-c *)
  lemma mat_sub_assoc0: forall a b c d : matrix. (d = mat_add a (mat_add b (c))) <-> (d = mat_add (mat_add a b) (c))
  lemma mat_sub_assoc2: forall a b c d : matrix. (d = mat_add a (mat_add b (mat_minus c))) -> (d = mat_add (mat_add a b) (mat_minus c))
  (* lemma mat_sub_assoc: forall a b c d : matrix. (d = mat_add a (mat_subtract b c)) <-> (d = mat_subtract (mat_add a b) c) *)

  (* (a-b)+c = a+(c-b) *)
  (* lemma mat_sub_chk3: forall a b c x y : matrix. (x = mat_add (mat_subtract a b) c) /\ (y = mat_add a (mat_subtract c b)) -> x=y *)
  (* lemma mat_sub_chk3: forall a b c x y : matrix. (x = mat_subtract (mat_subtract a b) c) /\ (y = mat_subtract a (mat_add b c)) -> x=y *)
  (* check associativity of subtract (a-b)-c = (a-c)-b *)
  (* lemma mat_assoc: forall a b c d e x y : matrix. (d = mat_subtract a b) /\ (x = mat_subtract d c) /\ (e = mat_subtract a c) /\ (y = mat_subtract e b) -> x=y *)

  (* matrix multiplication *)
  function mat_mult matrix matrix : matrix
  (* mult is monoid a.(b.c) = (a.b).c *)
  axiom matmult1: forall a b c d : matrix. (d = mat_mult a (mat_mult b c)) <-> (d = mat_mult (mat_mult a b) c)
  (* right distributive (a+b).c = a.c + b.c *)
  axiom matmult2: forall a b c d : matrix. (d = mat_mult (mat_add a b) c) <-> (d = mat_add (mat_mult a c) (mat_mult b c))
  (* left distributive a.(b+c) = a.b + a.c *)
  axiom matmult3: forall a b c d : matrix. (d = mat_mult a (mat_add b c)) <-> (d = mat_add (mat_mult a b) (mat_mult a c))
  
  (* some lemmas for sanity checking *)
  (* a.(b-c) = a.b - a.c *)
  (* lemma sanchk1: forall a b c d x : matrix. (d = mat_subtract b c) /\ (x = mat_mult a d) -> (x = mat_subtract (mat_mult a b) (mat_mult a c)) *)

  (* concatenation of matrices *)
  function hcat matrix matrix: matrix
  function vcat matrix matrix: matrix
  (* axioms for addition, part by part *)
  (* done via intermediate symbols so only implied if sizes are OK *)
  (* [a;c] + [b;d] = [a+b; c+d] *)
  axiom mat_cat_add1: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (vcat x y) = mat_add (vcat a c) (vcat b d)
  (* [a c] + [b d] = [a+b c+d] *)
  axiom mat_cat_add2: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (hcat x y) = mat_add (hcat a c) (hcat b d)
  (* [a b] * [c;d] = a*c + b*d *)
  axiom mat_cat_mult: forall a b c d x y z : matrix. (x = mat_mult a c) /\ (y = mat_mult b d) /\ (z = mat_add x y) -> z = mat_mult (hcat a b) (vcat c d)

  (* matrix transpose *)
  function mat_transpose matrix : matrix
  (* [A B]^T = [A^T; B^T] *)
  axiom mat_transpose1: forall a b : matrix. mat_transpose (hcat a b) = vcat (mat_transpose a) (mat_transpose b)
  (* [A;B]^T = [A^T B^T] *)
  axiom mat_transpose2: forall a b : matrix. mat_transpose (vcat a b) = hcat (mat_transpose a) (mat_transpose b)
  axiom mattrans1: forall a b : matrix. mat_transpose (mat_mult a b) = mat_mult (mat_transpose b) (mat_transpose a)
  (* lemma transchk1: forall a b c : matrix. mat_mult (mat_transpose a) (mat_mult b c) = mat_mult (mat_mult (mat_transpose a) b) c *)
  (* lemma transchk2: forall a : matrix. mat_transpose (mat_transpose a) = a *)

end  
