(* Created by Dejanira Araiza-Illan and Arthur Richards, UoB, 2014 *)

theory Matrix

  type matrix

  (* note size compatibility assumed throughout - must be checked numerically *)  

  (* start with basic ring axioms *)
  (* see https://en.wikipedia.org/wiki/Ring_(mathematics) *)
  (* properties defined as implications to avoid need for sizing *)

  (* matrix addition *)
  function mat_add matrix matrix : matrix
  (* add is commutative: if c = a+b then c = b+a *)
  axiom matadd1: forall a b c : matrix. (c = mat_add a b) -> (c = mat_add b a)
  (* add is associative iff d = a+(b+c) then d = (a+b)+c *)
  axiom matadd2: forall a b c d : matrix. (d = mat_add a (mat_add b c)) <-> (d = mat_add (mat_add a b) c)

  (* matrix subtraction *)
  function mat_subtract matrix matrix : matrix
  (* iff c = a+b then a = c-b *)
  axiom mat_subtract1: forall a b c : matrix. (c = mat_add a b) <-> (a = mat_subtract c b)
  lemma mat_sub_chk1: forall a b c : matrix. (c = mat_add a b) <-> (b = mat_subtract c a)
  (* sanity check: if c=b-a and d=a+c then d=b *)
  lemma mat_sub_chk2: forall a b c d : matrix. (c = mat_subtract b a) /\ (d = mat_add a c) -> d=b
  
  (* matrix multiplication *)
  function mat_mult matrix matrix : matrix
  (* mult is monoid a.(b.c) = (a.b).c *)
  axiom matmult1: forall a b c d : matrix. (d = mat_mult a (mat_mult b c)) <-> (d = mat_mult (mat_mult a b) c)
  (* right distributive (a+b).c = a.c + b.c *)
  axiom matmult2: forall a b c d : matrix. (d = mat_mult (mat_add a b) c) <-> (d = mat_add (mat_mult a c) (mat_mult b c))
  (* left distributive a.(b+c) = a.b + a.c *)
  axiom matmult3: forall a b c d : matrix. (d = mat_mult a (mat_add b c)) <-> (d = mat_add (mat_mult a b) (mat_mult a c))
  
  (* concatenation of matrices *)
  function hcat matrix matrix: matrix
  function vcat matrix matrix: matrix
  (* axioms for addition, part by part *)
  (* done via intermediate symbols so only implied if sizes are OK *)
  (* [a;c] + [b;d] = [a+b; c+d] *)
  axiom mat_cat_add1: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (vcat x y) = mat_add (vcat a c) (vcat b d)
  (* [a c] + [b d] = [a+b c+d] *)
  axiom mat_cat_add2: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (hcat x y) = mat_add (hcat a c) (hcat b d)
  (* [a b] * [c;d] = a*c + b*d *)
  axiom mat_cat_mult: forall a b c d x y z : matrix. (x = mat_mult a c) /\ (y = mat_mult b d) /\ (z = mat_add x y) -> z = mat_mult (hcat a b) (vcat c d)

  (* matrix transpose *)
  function mat_transpose matrix : matrix
  (* [A B]^T = [A^T; B^T] *)
  axiom mat_transpose1: forall a b : matrix. mat_transpose (hcat a b) = vcat (mat_transpose a) (mat_transpose b)
  (* [A;B]^T = [A^T B^T] *)
  axiom mat_transpose2: forall a b : matrix. mat_transpose (vcat a b) = hcat (mat_transpose a) (mat_transpose b)
  axiom mattrans1: forall a b : matrix. mat_transpose (mat_mult a b) = mat_mult (mat_transpose b) (mat_transpose a)
  lemma transchk1: forall a b c : matrix. mat_mult (mat_transpose a) (mat_mult b c) = mat_mult (mat_mult (mat_transpose a) b) c
  lemma transchk2: forall a : matrix. mat_transpose (mat_transpose a) = a

end  
