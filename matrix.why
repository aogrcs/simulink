(* Created by Dejanira Araiza-Illan and Arthur Richards, UoB, 2014 *)

theory Matrix

  type matrix

  (* note size compatibility assumed throughout - must be checked numerically *)  

  (* start with basic ring axioms *)
  (* see https://en.wikipedia.org/wiki/Ring_(mathematics) *)

  (* matrix addition *)
  function mat_add matrix matrix : matrix
  (* add is commutative a+b = b+a *)
  axiom matadd1: forall a b : matrix. (mat_add a b) = (mat_add b a)
  (* add is associative a+(b+c) = (a+b)+c *)
  axiom matadd2: forall a b c : matrix. mat_add a (mat_add b c) = mat_add (mat_add a b) c

  (* matrix zero *) 
  (* defined as setting all elements to zero *)
  (* to avoid need to add size concept explicitly *)
  function mat_zero matrix : matrix
  axiom mat_zero1: forall a : matrix. (mat_add a (mat_zero a)) = a

  (* matrix minus - additive inverse *)
  function mat_minus matrix : matrix
  axiom mat_minus1: forall a : matrix. (mat_add a (mat_minus a)) = (mat_zero a)

  (* which leads to substraction *)
  function mat_subtract matrix matrix : matrix
  axiom mat_subtract1: forall a b : matrix. (mat_subtract a b) = (mat_add a (mat_minus b))
  lemma mat_sub_chk1: forall a : matrix. mat_subtract a a = mat_zero a
  lemma mat_sub_chk2: forall a b : matrix. mat_add a (mat_subtract b a) = b
  
  (* matrix multiplication *)
  function mat_mult matrix matrix : matrix
  (* mult is monoid a.(b.c) = (a.b).c *)
  axiom matmult1: forall a b c : matrix. mat_mult a (mat_mult b c) = mat_mult (mat_mult a b) c
  (* right distributive (a+b).c = a.c + b.c *)
  axiom matmult2: forall a b c : matrix. mat_mult (mat_add a b) c = mat_add (mat_mult a c) (mat_mult b c)
  (* left distributive a.(b+c) = a.b + a.c *)
  axiom matmult3: forall a b c : matrix. mat_mult a (mat_add b c) = mat_add (mat_mult a b) (mat_mult a c)
  
  (* matrix identity *)
  (* size taken from column size of input *)
  function mat_eye matrix : matrix
  axiom mat_eye1: forall a : matrix. mat_mult (mat_eye a) a = a

  (* concatenation of matrices *)
  function hcat matrix matrix: matrix
  function vcat matrix matrix: matrix
  (* axioms for addition, part by part *)
  (* done via intermediate symbols so only implied if sizes are OK *)
  (* [a;c] + [b;d] = [a+b; c+d] *)
  axiom mat_cat_add1: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (vcat x y) = mat_add (vcat a c) (vcat b d)
  (* [a c] + [b d] = [a+b c+d] *)
  axiom mat_cat_add2: forall a b c d x y : matrix. (x = mat_add a b) /\ (y = mat_add c d) -> (hcat x y) = mat_add (hcat a c) (hcat b d)
  (* [a b] * [c;d] = a*c + b*d *)
  axiom mat_cat_mult: forall a b c d x y z : matrix. (x = mat_mult a c) /\ (y = mat_mult b d) /\ (z = mat_add x y) -> z = mat_mult (hcat a b) (vcat c d)

  (* matrix transpose *)
  function mat_transpose matrix : matrix
  (* [A B]^T = [A^T; B^T] *)
  axiom mat_transpose1: forall a b : matrix. mat_transpose (hcat a b) = vcat (mat_transpose a) (mat_transpose b)
  (* [A;B]^T = [A^T B^T] *)
  axiom mat_transpose2: forall a b : matrix. mat_transpose (vcat a b) = hcat (mat_transpose a) (mat_transpose b)
  lemma mattrans1: forall a b : matrix. mat_transpose (mat_mult a b) = mat_mult (mat_transpose b) (mat_transpose a)
  lemma transchk: forall a b c : matrix. mat_mult (mat_transpose a) (mat_mult b c) = mat_mult (mat_mult (mat_transpose a) b) c

end  
